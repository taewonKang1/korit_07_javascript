
# JavaScript 내장 객체
ch02_js_object / 01_js_methods.html

# Object 객체
내장 객체(Built-in Object)는 브라우저의 Js 엔진에 내장된 객체를 의미함
모든 Object 객체는 모든 JS의 루트 객체

String, Number, Date, Array, Math, etc...

## String 객체
문자열을 다루는 property / 함수를 제공

1. length
```js
let txt = 'abcd';
let txtlength = txt.length;
console.log('문자열의 길이는 ' + txtlength + '입니다');
```

2. indexOf() 
문자열 안에 특정 문자열이 존재하는지를 찾고, 문자열이 시작되는 index를 반환하는 method.
- 문자열을 찾기 못하면 -1를 return

3. lastIndexOf()
다 비슷한데 찾고자 하는 문자열이 둘 이상 반복되면 2제일 마지막에 발견된 문자열의 index를 return.
- 문자열을 찾지 못하면 -1을 return

4. slice()
매개변수로 시작 위치 / 종료 위치를 줬을 때 문자열의 해당 부분을 잘라내서 return하는 method

5. substring()
- slice()랑 다 똑같은데 마이너스 인덱스가 없습니다.

6. substr()
- slice()랑 비슷한데 두 번째 매개변수가 한계값 미만을 지시하는게 아니라, 첫 번째 매개변수로부터 문자 개수를 의미합니다.

7. replace()
- 문자열 내의 특정 문자열을 지정한 문자열로 바꾸는 함수
- 마치 vs code 상에서 ctrl + r 누르면 문자열 검색해서 바꿀 수 있는 거랑 동일한 기능입니다.

- 정규식과 조합했을 떄 다양하게 replace() 적용이 가능합니다.
  - '/i' : insensitive - 대소문자 구분 안함
  - '/g' : global - 일치하는 문자열 전체 replace() 적용

8. toUpperCase(), toLowerCase()
9. concat()
- 두 개 이상의 문자열을 하나의 문자열로 합치는 method
10. trim()
- 문자열 앞/뒤 공백을 모두 제거하는 함수
- DB에 공백이 있으면 조회할 때 실패하는 경우가 있어 공백 제거하고 조회하는 일이 많습니다.

11. charAt()
- 문자열에서 특정 인덱스에 해당하는 문자 하나를 반환하는 method

12. charCodeAt()
- 문자열에서 특정 인덱스에 해당하는 문자의 _유니 코드_ 값을 반환

13. split()
- 문자열 내의 특정 기준을 가지고 문자열을 분리하여 _배열_ 로 반환하는 method

14. startsWith(), endsWith()
- 문자열의 시작 혹은 끝이 매개변수로 전달된 값으로 이루어져있는지 확인하는 method

- return type boolean 입니다

  - 실무 사례
    startsWith('https')를 해서 보안이 뛰어난 https로 접속했는지를 확인합니다. 이상의 경우 false가 나오게 되면 http로 접속했다는 뜻이 되겠네요. endsWith()의 경우에는 특정 파일 확장자인지를 체크하는 용도로 쓰입니다.
    endsWith('.pdf'); 와 같은 방식입니다.

## Number 객체
02_js_number_methods.html

1. toString() - 설명 생략
2. toFixed()
- 소수점 몇 번 째 자리까지 보여줄지를 결정하는 method.
- 매개변수로 소수점 자리수 사용
- 반올림 적용

3. toPrecision()
- 2번과 다르게 정수와 소수를 포함해서 몇 번째 자리까지 보여줄지 결정하는 method

4. parceInt()
- 전역 함수로 정수로 반환
문자열의 시작이 number면 number로 반환

5. parseFloat()
- 전역 함수로, 부동소수점으로 반환


## Array 객체
03_js_array_method.html

1. toString()
- 배열 내의 elementemfdmf ',' 기준으로 모두 결합하여 하나의 문자열로  return

2. join()
- 배열 내의 모든 문자를 매개변수로 지정한 문자를 이용하여 element들을 구분함
`배열명.join('/')` 라고 가정했을 경우
결과값은
요소1/요소2/요소3.. 으로 / 기준으로 결합됨

3. pop()
- 배열에서 마지막 데이터를 제거하고, 마지막 데티어를 return

4. push()
- Java Collection에서 list / set에서 .add()와 같습니다.

5. shift()
- pop() 과 달리 첫 번째 element를 제거하고 그 element를 return

6. unshift()
- 배열의 맨 앞에 element를 추가하고, 배열의 index를 return

- 굳이 맨 앞에 추가하는 method가 따로 있는 실무 사례
  - HTML 문서 작성 시에 `<select>` 태그 구현할 때. 예를 들어서 DB에서 지역 목록 가져오고, 가져온 지역 목록을 `<select>`태그의 `<option>`태그로 추가하려고 할 때, `<select>` 태그에서 사용자에게 제일 먼저 보이는 옵션이 '선택하세요'와 같은 정보성 글입니다. 이럴 때, DB에서 '선택하세요'가 있지 않을 테니까 unshift('지역을 선택하세요'); 로 배열에 추가하는 방식이 있습니다.
  - 혹시 헷갈리신다면 html css 파일에서 ctrl + shift + f 'select'로 검색

7. 배열 element 변경
```js
let subs = ['국어', '수학', '영어', '자바', '자바스크립트'];
sub[0] = '파이썬';
```

8. splice()
- 새로운 element 를 특정 위치에 추가하는데, 기존 element를 삭제도 가능.

```js
let fruits2 = ['Banana', 'Orange', 'Apple', 'Mango'];
fruits2.splice(2, 0, 'Lemon', 'Kiwi');
console.log(fruits2);
// 결과값 : [ 'Banana', 'Orange', 'Lemon', 'Kiwi', 'Apple', 'Mango' ]
```
splice(2, 0, 'Lemon', 'Kiwi')의 매개변수 복록

1. 2-새로운 element를 추가할 인덱스 넘버
2. 0-첫 번째 매개변수에 해당하는 인덱스에서 element를 추가하기 _전_ 에 삭제할 element 수
  - 저희는 0으로 지정했으니까 아무것도 삭제되지 않았습니다.
3. 'Lemon', 'Kiwi', ...etc-나머지 매개변수는 추가할 element들에 해당합니다.

9. concat()
- 2 개 이상의 배열을 하나의 배열로 결합

10. slice()
- String에서와 동일
- 근데 배열 형태로 return

11. sort() -> 오름차순 정렬입니다.
12. reverse() -> 내림차순 정렬입니다.
  - Java 처럼 골치 아프게 안해도 됩니다.

13. filter()
- 배열에서 특정 조건을 만족하는 배열의 element만을 찾아서 _새로운 배열_ 로 return 합니다.

- 배열 다룰 때 제일 많이 쓰고 프론트엔드에서도 자주 사용하는 method

- 특정 조건을 만족하는 데이터만 추출해내는 프로그램을 작성하는 경우가 빈번한데, 이때 filter()를 쓰기 때문에 필수적이라고 할 수 있습니다.

형식
`배열명.filter(콜백함수([, index[, 배열]])[, thisArg])`

filter() method에는 특정 조건을 체크하는 callback 함수를 매개변수로 전달합니다.

여기서의 callback함수는 배열의 각 element를 시험할 함수에 해당합니다. 시험을 통과(true) 하게 되면 element 를 그대로 유지하고, false라면 버리게 됩니다. 즉 true인 element들만 모아서 _새로운 배열_ 을 생성합니다,

callback 함수의 매개변수는,
  - element - 처리할 현재 element(기존 배열의 element를 의미합니다)
  - index(optional) - 처리할 현재 element의 인덱스
  - array(optional) - 배열 전체

```js
let words = ['부산광역시', '부산시', '서울특별시', '서울', '경상남도 남해시', '남해시', '광주광역시', '경기도 광주시', '오사카부 오사카시', '오사카'];

let result = words.filter(function(word) {
  return word.length > 4;
});

console.log(result);
// 결과값 : [ '부산광역시', '서울특별시', '경상남도 남해시', '광주광역시', '경기도 광주시', '오사카부 오사카시' ]
```

14. map()
- 배열 내의 element가 object일 때 배열에 담긴 object를 _새로운 형태의 object_ 로 반환하여 배열로 return

15. reduce()
- 배열에 담긴 element를 하나씩 순회하며 callback 함수의 실행값을 _누적_하여 return하는 method. 누적 결과 값은 숫자, 문자, 객체 모두 가능.

- 주로 배열 내의 element 데이터의 합계를 구할 때 많이 사용됩니다.

- 배열 내의 element가 객체인 경우 누적 값을 구하고자 하는 object의 property를 참조해서 씁니다.(persons라면 person[0].score가 되겠네요.)

```js
// reduce()
let scores = [40, 100, 1, 5, 25, 10];
let sum = scores.reduce(
  function(total, currentValue) {
    return total + currentValue;
  }
);

console.log(sum); // 결과값 : 181
```
reduce() method 내의 callback 함수는 4 개의 매개변수를 가질 수 있습니다(주로 2 개만 쓰고 나머지는 optional입니다.)

- 1 번 매개변수 : accumulator(누적값 - 저희는 total 썼습니다)
- 2 번 매개변수 : currentValue(배열의 현재 element, 저희는 currentValue)
- 3 번 매개변수 : currentIndex(현재 index 넘버)
- 4 번 매개변수 : arr(배열)

## Set 객체

1. Set 생성자
```js
let mySet = new Set();
```

2. add() - Java와 같습니다
3. has() - 특정 데이터가 있는지 확인합니다. return boolean
4. delete() - 특정 데이터를 삭제합니다.
5. clear() - 저장되어있는 모든 데이터를 삭제합니다.
6. forEach() - set에 저장된 모든 데이터를 읽어줍니다
```js
mySet.forEach(fucntion(item) {
  console.log(item);
});
```

## Map 객체
1. Map 생성자
```js
let userMap = new Map();
```
2. set() - Map 객체에 데이터 저장할 때 쓰는겁니다.
Java에서의 맵이름.put("키", "값");과 동일
3. get() - Java에서의 맵이름.get("키");dhk ehddlf
4. has() - 특정 키의 값이 저장되어있는지 확인 return boolean
5. delete() - 특정 데이터를 삭제
  user.delete('name');
6. clear() - 저장되어있는 모든 데이터 삭제
7. forEach() - 저장되어있는 모든 데이터 읽기
```js
userMap.forEach(function(item) {
  console.log(item);
});
```

### JavaScript Object vs. JavaScript Map

1. Object는 key를 string으로만 지정해야 하지만 Map은 다른 타입도 가능합니다.
2. Object는 몇 개의 데이터가 담겼는지 수동 계산해야하지만 Map은 맵이름.size 로 크기를 알 수 있습니다.
3. Object는 저장된 데이터를 for-in(이제 수업)으로 읽었을 때 순서를 보장하지 않지만 Map은 데이터를 지정한 순서대로 읽어옵니다. (근데 Java Map은 또 순서를 보정하지 않습니다)

## JSON 객체
04_jason _metho.html

- 데이터를 저장하거나 전송할 때 많이 사용되는 _경량_ 외 데이터 교환 형식입니다.

- 다수의 플랫폼에 사용됨

  1. 서버와 클라이언트 간의 데이터 전송 시 많이 사용.
  2. JavaScript의 Object 객체 표기법과 매우 _유사_
  3. JSON 데이터는 JavaScript JSON객체의 parse() method를 이용하면 JavaScript Object 객체로 변환하여 사용가능
  4. 프로그래밍 언어와 상관없이 사용할 수 있는 _데이터 교환 방식_
  5. 대부분 언어에서 JSON 데이터를 처리할 수 있는 라이브러리 제공(Java는 GSON이었습니다.)


### 중요 내장 함수 목록
1. JSON.stringify(Object) - 데이터를 서버로 전송하기 위해서 데이터 형태를 문자열로 변환(이유: 가벼워서)해줍니다. 여기서는 JavaScript 객체를 문자열로 변환해줍니다.

2. JSON.parse(JSON명) - 서버로부터 응담받은 JSON 데이터를 JavaScript Object의 객체로 변환해줍니다.

## Window 객체
05_js_window.html / .js
window 객체는 전역(global) 객체입니다. 현재는 브라우저라고 생각해도 무방합니다.

1. alert() - 윈도우 화면에 경고 메세지를 출력
2. confirm()- return type boolean

```js
if(confirm('정말 삭제하시겠습니까?')) {
  // 삭제 로직
  console.log('삭제');
}
```

3. prompt()
```js
let txt = prompt('비밀번호를 입력하세요');

if(txt == null) {
  //취소 버튼을 눌렀을 때의 로직
} else if(txt == ''){
  // 아무 값도 입력하지 않고 확인 버튼 눌렀을 때의 로직
} else if(txt !== ''){
  // 어떤 값을 입력하고 확인 버튼을 눌렀을 떄.
  // 그럼 여기에 비밀 번호 일치 했을 때와 아닐 때의 조건들이 추가로 들어가야곘네요.
}
```
4. open() - 윈도우 새창 / 새 탭으로 지정한 url을 오픈하는 함수

5. setTimeout() / clearTimeout()
  - setTimeout() 함수는 두 번째 매개변수로 지정한  시간 간격 이후에 첫 번째 매개변수에 정의한 함수를 실행시킴. callback 개념을 알아야 써먹을 수 있습니다.

  - clearTimeout() - setTimeout() 함수에서 정의한 함수가 실행되지 않았을 떄, setTimeout()의 콜백 함수를 실행시키는 것을 중지할 때 사용.

  - 밀리초 사용합니다.

ch03_js_applied

# JavaScript 고급 문법(이지만 front에서 그냥 다 쓰는)

## Default Function Paramete
- 함수를 호출할 때 예를 들어, `function(message) { return 어쩌고 };` message가 비어있는 상태가 되며느 호출 단계에서 argument가 없기 때문에 오류(undefined)가 발생합니다. 만약에 매개변수가 함수 내에서 특정 기능을 구현하기 위해서 반드시 요구된다면, _아무런 값이 없을 경우_ 함수를 호출할 때마다 체크를 해야할 겁니다

```js
function say(message) {
  if(message !== undefined) {
    console.log(message);
  } else {
    console.log('매개변수가 입력되지 않았습니다.');
  }
}

say();  // argument 없이 함수를 호출했을 경우에는
// 결과값 : 매개변수가 입력되지 않았습니다.
```

Default function parameter를 지정하게 되면, argument 없이 함수를 호출했을 때, 미리 설정해둔 기본값으로 함수를 호출하여 오류가 발생하지 않게끔 하는 사전 작업.

```js
function say(message='매개변수가 입력되지 않았습니다.') {
  console.log(message);
}

say();
```
## Rest Parameter
일반적인 함수 선언식으로 함수에 따라 몇 개의 argument가 요구되는지 미리 선언합니다. 매개변수 2개 짜리로 정의하면 함수 호출 시에 2 개의 argument를 요구하고, 4 개 짜리를 정의하면 함수를 호출할 때 4 개의 argument를 요구하겠죠. 근데 우리가 3개 짜리로 쓰고 싶으면 어떡해야하냐, 뭐 이런 문제가 있습니다.

문제 사례
```js
function sum(x1 + x2) {
  return x1 + x2
}

sum(5, 7);

function sum(x1, x2, x3, x4) {
  return x1 + x2  + x3 + x4;
}

sum(5, 7, 8, 10);
```
하지만 3 개 짜리의 연산으 불가능해서 sum(1, 2, 3, 0); 같은 꼼수를 써야만 할겁니다.
Rest Parameter 의 개념은 몇 개의 매개변수가 전달될지 모르는 상황에서 매우 유용합니다.

Rest Parameter  적용 예시
```js
function sum(...args) {// 이렇게 매개변수를 선언하면, 함수 호출 시에 매개변수 개수에 상관없이 할당 가능하고, 이렇게 할당된 값은 _배열_로 지정
  let total = 0;
  // 배열로 저장되기 때문에 element를 추출하여 합 연산을 해야함
  for(let x of args) {
    total += x;
  }

  return total;
}

sum(1,2,3);
sum(2,3,4,5,6,12123212);
```

## Arrow Function(Lambda Expression의 JS ver.)
기존의 함수 표현 방식들
1. 함수 선언식
```js
function hello(name) {
  return 'hello' + name;
}
```
2. 함수 표현식
```js
const hello2 = function(name) {
  return 'hello' + name;
}
```
hoisting 여부로 인해 #1, #2 방법이 생겨났습니다.

화살표 함수는 함수를 정의하는 비교적 최근 방법입니다.(저희는 람다에서 배웠지만 여기서 훨씬 많이 써먹습니다.) 화살표 함수를 사용해서 함수를 정의하면 구문이 짧아진다는 장점이 있습니다. 단점은 람다에서 봤던 것처럼 너무 복잡한 로직을 구현하기는 힘들다는 점입니다.

3. 화살표 함수
```js
const hello3 = (name) => {return 'Hello ' + name};

// 매개변수가 하나라면 소괄호()를 생략할 수 있다
const hello4 = name => {return 'Hello ' + name};

// 실행문이 한 줄이라면 return  / 중괄호({})를 생략할 수 있다
const hello5 = name => 'Hello ' + name;

// 매개변수가 없다면 빈 소괄호를 사용함
const hello6 = () => 'Hello, there';
```
## Template Literals
```js
// 1. 기존 작성 방식
function hello(name) {
  console.log('Hello ' + name + '.환영합니다!'); 
}

// 2. 템플릿 리터럴 적용 방식
function hello2(name) {
  console.log(`Hello ${name}. 환영합니다!`);
}
```
2의 장점은 중간에 ++ 기호 넣는다고 오류 발생할 확률이 적다는 점입니다.
단점은 대충 보면 얘가 '' 인지 ``인지 구분할 방법이 없다는 겁니다
그래서 차라리 중간에 ${}가 있으면 템플릿 리터럴이 적용되었다고 보는게 여러분들의 정신건강에 좋습니다.

01_js_applied.html

## Object Literal Syntax Extension
```js
// 1. 기존 방식
let fName = 'Josh';
let lName = 'Smith';

let person = {
  fName: fName,// 앞은 person의 property고 뒤는 425번 라인의 변수죠.
  lName: lName,
};

// 2. Object Literal
let type = 'student';
let score = {
  [type]: 'Josh',
  score: 92,
};
```
2. 번에서 Object의 key에 [] 가 있다는 점을 확인할 수 있습니다. JS 객체으 key를 []로 감싸게 했을 때는 '할당된 변수 값'을 의미하게 됩니다
이상의 장점으로는 Js 객체의 key를 _동적으로_ 생성 가능합니다.

## Spread Operator(JS에서 처음 배웁니다.)
- 배열, 문자열 등 반복가능 객체 형태의 데이터를 element하나하나로 분해해서 사용할 수 있도록 함.


## Object Destructuring(객체 구조분해)
## Array Destructuring


# JS HTML DOM
ch04_js_dom
- DOM(Document Object Model)
- JS는 HTML 문서의 모든 요소에 접근하여 변경할 수 있습니다. 간단하게는 `<table>`태그 내에 `<td>`를 추가할 수 있을겁니다.

1. 모든 HTML element
2. HTML 태그의 속성(특성)
3. CSS 스타일
4. HTML element 및 속성을 제거
5. 새로운 HTML element 및 속성을 추가
6. 페이지 내에 존재하는 모든 HTML 에벤트에 대한 반응
7. 새로운 HTML 이벤트 추가
## DOM Element
01_domelement.html

JS에서 HTML element에 대한 다양한 제어를 위해 가장 먼저 할 일은 HTMl element에 대한 접근입니다. JS 상에서 HTML 요소를 찾는 방법은

1. id값을 통해,
2. 태그명을 통해,
3. class명을 통해,
4. CSS의 선택자 개념을 통해 찾을 수 있습니다

- HTML element의 id로 찾기
  - HTML 태그의 id 속성은 고유값이기 때문에 단일한 결과가 나옵니다.
  - 만약에 id가 정확하다면 JS 객체의 형태로 HTML element가 return
  - 일치하는 id가 없다면 null return
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM element</title>
</head>
<body>
  <input id="userid" type="text">
  <p>태그명을 사용해서 HTML 요소를 찾습니다. document.getElementById</p>
  <script>
    let element = document.getElementById('userid');

    console.log(element);
  </script>
</body>
</html>
```

## DOM Attribute
- 태그명을 통한 HTML element 추출
02_js_dom_tag.html

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>태그명을 통한 HTML element</title>
</head>
<body>
  <p>HTML 요소에 대한 접근</p>
  <p>
    태그명을 사용하여 HTML element를 추출합니다. <br>
    document.getElementsByTagName('p');
  </p>
  <script>
    let elements = document.getElementsByTagName('p');
    console.log(elements);
  </script>
</body>
</html>
```
- id값을 통한 추출과 태그명을 통한 추출에서의 차이점은 id는 고유값인데 반해 태그는 한 HTML 문서 내에 복수로 있을 수 있으므로, return 타입이 JS 객체 하나짜리가 아니라, JS 객체를 element로 하는 배열이 return된다는 점입니다.

- 이를 명확히 확인하기 위해서 method 명을 보시면
- getElement's'ByTagName이라고 명시되어 있는 점을 알 수 있습니다.

- 클래스명을 통한 HTMl 요소 찾기
- CSS 선택자를 이용한 HTML 요소 찾기


## HTML 내용 변경
03_js_html.html
1. innerHTML
  - HTML의 특정 위체에 새로운 HTML을 삽일할 떄 사용.

2. innerText
  - 1과 비슷하지만 텍스트 내용만 삽입 가능함.

## DOM event(클릭 이벤트 등)
웹 페이지를 이용하면 웹 화면과 사용자 사이에 상호작용이 나타납니다. 예를 들어,
1. 버튼을 클릭한다든지,
2. 마우스를 스크롤한다든지,
3. 검색을 위해 검색 키워드를 input창에 입력한다든지 하는 행동 등.
이상의 모든 상호작용을 event라고 합니다

### click 이벤트(onclick) - 골치아픈게 react에서는 onClick입니다.
마우스 좌클릭할 때 발생하는 이벤트 입니다. 검색 / 저장과 같은 버튼을 클릭하면, 이때 클릭 이벤트가 발생합니다. 

대표적인 예로 `<button>` 요소에 클릭 이벤트가 일어나는지를 감시하고, 클릭 이벤트가 일어나는 순간 특정 함수를 실행시켜야겠네요.

이때 `<button>` 태그 내의 onclick 속성을 이용하여 처리할 수 있습니다.

- 검색 버튼을 클릭하면 검색 기능이 실행되어 화면에 검색 결과를 출력,
- 저장 버튼을 클릭하면 사용자가 입력한 데이터를 서버로 보내고 DB에 저장,
- 메뉴 버튼을 클릭하면 해당 메뉴로 이동 등

04_click_event.html

### change 이벤트 (onChange)
- 값이 변경되었을 때 발생하는 이벤트
- 대표적으로는 `<select>`, `<input type="checkbox">`, `<input type="radio">`에서 발생합니다.

05_change_event.html

### key 이벤트(onkeydown, onkeyup, onkeypress)
key 이벤트는 사용자가 입력창에서(`<input>` 태그에서) 키보드를 입력할 때 발생
사용자가 키를 입력하면 keydown -> keypress -> keyup의 순서로 이루어집니다.

input type="text"에 keydown / keypress / keyup 이벤트를 모두 받을 수 있도록 설정하고, 순서를 검증하겠습니다.

06_key_event.html

현재 상황에서 chorme 자체에서 stricmode로 실행 중이기 때문에 두 번씩 찍혀서 콘솔상에서 명확하게 안보이실 수 있지만 입력 시점에서 onkeydown이 일어나고 키를 뗐을 때 onkeyop이 일어나는 것을 볼 수 있습니다.

# JS 주요 Web APIs
ch05_webapi
## LocalStorage / SessionStorage

까지하고 배운거 응용해서 Todo List JS 만들기 해보겠습니다.