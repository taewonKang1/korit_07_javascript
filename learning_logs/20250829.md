
# JavaScript 주요 Web API
## API란?
Application Programming Interface의 축약어로, 응용 프로그램이나 시스템이 서로 통신하고 상호작용할 수 있도록 돕는 인터페이스.

비유적으로, 식당에서 손님(클라이언트)이 주문(_요청_)을 하면 주방(서버)에 전달하고, 주방에서 요리(데이터 처리)를 완성하면 손님에게 가져다 주는 _웨이터_ 역할

어제 수업한 것 중에 person 객체에 fName / lName이라는 재료를 가지고 fullName을 만들어내는 등의 처리는 저희가 했죠.

## API의 구성 요소
1. 명세(Specification) : API가 제공하는 기능 목록과 사용 방법을 정의한 문서.
2. 인터페이스(Interface) : 실제로 통신을 위한 규익. 주로 HTTP 프로토콜을 사용(추후 수업 예정)

## Web API
웹 애플리케이션 개발에 사용되는 API로, 웹 서버와 클라이언트(웹 브라우저 / 모바일 앱 등) 같은 통신을 가능하게 함.

## 특징
1. HTTP 프로토콜 기반 : 웹에서 데이터를 주고 받을 떄 사용하는 방식으로 저희도 프로젝트를 할 때 이용할 예정.
2. RESTful API : 최근에 가장 널리 사용되는 웹 API 스타일로. HTTP 메서드를 사용해 데이터를 처리하는 방식/
3. 데이터 형식 : 주로 JSON 사용. 혹은 XML(extensible markup language).

### LocaStorage / SessoionStorage
- HTML5에서 추가된 웹 브라우저 자체 저장소.
1. LocalStorage
  - 저장된 데이터를 삭제하기 전까지 영구히 보존됨(그 말은 우리가 알아서 삭제도 잘 해줘야 한다는 의미가 되겠네요.)
  - 저장되는 모든 데이터는 JS의 object처럼 key- value properties로 이루어져 있음.
  - 그런데 value의 자료형은 string으로 고정됨.
  - 이상을 이유로 다양한 자료형의 데이터를 저장하고자 할 때 JSON.stringfy를 이용해 문자열로 변환시켜 저장해야 합니다.
  - 반대로 LocalStorage 내의 데이터를 불러와서 웹 페이지에 출력하고자 한다면 JSON.parse를 이용해 원래 데이터 형식으로 변환해야 함.
  - 보안에 위배되지 않고, 영구히 저장해도 상관없는 데이터를 저장할 떄 적합
    - 사용자가 마지막으로 보고 있는 화면 url
    - 웹 사이트에서 사용자 테마, 개인화를 제공하는 경우 해당 정보 저장

```js
// localStorage에 문자열 데이터와 배열 데이터를 자정하는 예시
if(typeof Storage !== 'undefined') {  // Storage가 검색됐으니 별문제 없을겁니다
  localStorage.setItem('title', 'review : 파이팅');
  /*
  .setItem() 라는 메서드가 있고, 거기에 2 개의 argument를 집어넣습니다. 두 번째 매개변수인 value값의 경우, 원래 string 자료형이라면 있는 그대로.
  */

  // 집어넣을 데이터 예시 - JS 배열인데, 내부 element가 객체 -> string 으로의 변환 과정 필요
  const users = [
    {
      id: 1,
      name: '김일',
    }, {
      id: 2,
      name: '김이',
    }, 
  ];
  localStorage.setItem('users', JSON.stringify(users));
}
```

1. 이상의 코드 라인에서 확인할 것은 Java에서 배웠던 setter / getter 개념이 동일하게 사용되었다는 점
2. localStorage 상의 key-value의 자료형이 둘 다 고정되어 있으므로, value가 string이외의 다른 자료형이라면 변환 과정이 필요하다.
  - 변환을 위한 method는 JSON.strigify(바꾸고자하는데이터);
  - 저희는 live server 사용 중이라서 그냥 연동해두면 알아서 들어가 있습니다.

localStorage 상에 데이터가 저장되면, 같은 도메인 내의 다른 페이지에서도 저장된 데이터를 조회할 수 있게 됩니다(A사이트의 로그인 창에서 id/비밀번호 입력하고 authentication 적용되면 A 사이트 내의 다른데서도 이용가능하듯이).

```js
// localStorge 내에 있는 데이터를 조회하는 예시
if(Storage !== undefined) {
  console.log(localStorage.getItem('title'))
  console.log(localStorage.getItem('users'))
  // 이 경우 23 / 24 번 라인의 결과값 자료형들은 전부 string에 해당함
  // 그래서 그냥 27 번 라인을 string으로 쓸거라면 별 문제가 없겠지만 굳이 객체 정보로 저장한걸 string으로 쓸 리가 없으니까 다시 원상복구하는 method가 필요합니다
  console.log(JSON.parse(localStorage.getItem('users')));

  const usersFromLocal = JSON.parse(localStorage.getItem('users'));
  console.log(usersFromLocal[0].name);
}

// 삭제 예시
localStorage.removeItem('title');
```

그러면 사실상 localStorage 상에서 여러분들이 알아야 할 것은
  1. setItem('키', '값') / getItem('키') / removeItem('키'); method 세 가지
  2. value로 들어가게 되는 데이터의 자료형
    -  string이면 그대로
    - 아니면 JSON.stringify() 적용
  3. getItem 사용시 localStorage에 들어가있는 value들은 전부 string이므로
    - string이면 그대로 가지고 오면 되고,
    - 원래 형태가 string이 아닌 것 같다면([]로 시작하든지 {}로 시작하든지 등), JSON.parse('키') 사용

2. sessionStorage
  - 세션스토리지에 저장된 데이터는 브라우저를 닫으면 자동으로 삭제됨,
  - method명 동일
  - 저장되는 방식 동일하기 때문에 JSON.stringify() / JSON.parse()를 동일하게 사용함.

# TodoList 작성
ch06_todoList
01_todolist.html
## 요구사항 명세서
1. 개요(Introduction)
이 문서는 사용자가 할 일을 효율적으로 관리할 수 있도록 돕는 투두 리스트 웹 애플리케이션의 요구 사항을 명세합니다. 사용자가 할 일을 추가, 관리, 삭제할 수 있는 기능을 제공하며, 웹 브라우저의 `localStorage`를 활용하여 데이터를 영구적으로 저장합니다.

2. 기능 요구사항(Functional Requirements)
- 할 일 추가(Add To-Do) :
  - 사용자는 텍스트 입력창(`<input>`태그)에 할 일을 입력하고 '추가' 버튼을 클릭하거나 enter키를 눌러 할 일을 목록에 추가할 수 있어야 합니다.
  - 입력된 텍스트는 공백을 제거한 후 저장되어야 합니다.
  - 입력 내용이 비어 있을 경우, 사용자에게 경고 메세지를 표시해야 합니다.
  - 새로 추가된 할 일은 '완료되지 않음'상태로 추가되어야합니다.

- 할 일 표시(Display To-Do) :
  - 추가된 할 일은 순서대로 목록에 표시되어야 합니다.
  - 각 할 일 항목에는 체크박스, 할 일 내용, 삭제 버튼이 포함되어야 합니다.

- 할 일 상태 변경(Change To-Do Status) :
  - 사용자는 각 할 일 옆의 체크 박스를 클릭하여 해당 할 일의 '완료' 상태를 변경할 수 있어야 합니다.
  - '완료됨' 상태의 할 일은 시각적으로 구분될 수 있도록 _취소선_ 과 _흐릿한 색상_ 이 적용되어야 합니다.

- 데이터 영구 저장(Data Persistence) :
  - 애플리케이션은 브라우저의 `localStorage`를 활용하여 할 일 목록 데이터를 저장해야 합니다.
  - 페이지를 새로고침하거나 브라우저를 닫았다가 다시 열어도 기존의 할 일 목록이 유지되어야 합니다,

3. 기술 요구 사항(Technical Requirements)
  - 언어 및 기술 :
    - HTML / CSS / JavaScript를 사용해야 합니다. 외부 라이브러리나 프레임워크는 사용하지 않습니다.
    - JavaScript 내장 객체 및 메서드를 활용
      - JSON 객체
      - Array 객체
      - String 객체

    - DOM 조작 :
      - document.getElementById()를 사용해 HTML element를 선택해야 합니다.
      - 기타 다른 document 관련 method를 활용해야 합니다.

    - 이벤트 처리 :
      - addEventListner()를 사용하여 click 이벤트와, keydown 이벤트를 처리해야 합ㄴ디ㅏ.
      - 체크박스의 change 이벤트도 처리하여 할 일의 완료 상태를 업데이트 해야 합니다.

- 디자인 및 사용자 경험 (UX)
  - 직관적인 디자인과 사용자 친화적인 레이아웃을 제공해야 합니다.
  - 모바일 기기에서도 사용 가능하도록 _반응형 디자인_ 이 적용되어야 합니다.
  - 할 일 추가, 상태 변경, 삭제 시 시각적 효과를 통해서 사용자가 즉각적인 피드백을 받을 수 있어야 합니다.

## CSS 변수 명세서
1. 색상(Colors) :
- 프로젝트의 주요 색상을 정의합니다.
  - --primary-color : #2c3e50
    - 용도 : 주요 텍스트, 제목 등 핵심 요소에 사용되는 기본 색상

  - --secondary-color : #3498db
    - 용도 : 상호작용 가능한 요소(버튼 / 링크 등)나 강조를 위한 색상

  - --light-gray : #bdc3c7
    - 용도 : 비활성화된 요소나 경계선(border) 등 보조적인 요소에 사용되는 밝은 회색

  - --completed-color : #95a5a6
    - 용동 : 완료된 할 일 텍스트에 사용되는 색상

2. 폰트(Typography)
- 프로젝트 글꼴을 정의합니다.
  - --font-family : Noto Sans KR, sans-sherif
    - 용도 : 전체 애플리케이션에 사용되는 기본 글꼴

3. 레이아웃 및 간격 (Layout / Spacing)
- 컴포넌트의 크기와 간격을 정의합니다.
  - --container-padding : 2.5rem
    - 용도 : 메인 컨테이너의 내부 여백

  - --container-radius : 15px
    - 용도 : 메인 컨테이너의 모서리 둥글기

  - --item-padding : 15px
    - 용도 : 개별 할 일 아이템의 내부 여백

  - --item-radius : 8px
    - 용도 : 입력창, 버튼, 할 일 아이템의 모서리 둥글기

  - --gap : 10px
    - 용도 : 입력 그룹 내 요소 간의 간격

4. 그림자(Shadows)
- 입체감을 위한 그림자 효과를 정의합니다.

  - --container-shadow : 0 10px 25px rgba(0, 0, 0, 0.1)
    - 용도 : 메인 컨테이너에 적용되는 그림자

  - --item-hover-shadow : 0 5px 15px rgba(0, 0, 0, 0.05)
    - 용도 : 할 일 아이템에 마우스를 올렸을 때 적용되는 그림자

.js 파일로 분리
기본적인 구조를 만들었다면

웬만하면 수정하지 않고
쇼핑리스트 만들 겁니다.
입력 부분 input창을 두 개로 만들거에요 -> 품목 / 가격

ch06_todolist -> shoppinglist -> 01_shoppinglist.html / 01_shoppinglist.js

작성을 다 했다고 가정했을 때, 저희는 
현재 01_shoppinglist.html에 01_todolist.css를 도입을 했습니다.
<img src="./image01.png">

그러니까 생기는 문제점이 있었습니다.
이를 해결하기 위한 방법은 무엇일까요? 그리고, 무엇이 가장 날로먹는 방법이 될까요

1. 01_shoppinglist.css 를 만들고, 01_todolist.css의 코드를 전부 다 긁어서 복사하고, 01_shoppinglist.css 에서 수정한다.
  - 혹시 수정하다가 잘못건드려서 todolist의 css에 깨지면 골치 아파서

2. 01_shoppinglist.css를 만드는 것까지는 좋은데, 우리가 좀 고급 css 배우면 했던 방식을 쓴다. -> 힌트 : 모듈화